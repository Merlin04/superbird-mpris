// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v4.25.3
// source: mpris_pb.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

export const protobufPackage = "";

export enum LoopStatus {
  LOOP_STATUS_NONE = 0,
  LOOP_STATUS_TRACK = 1,
  LOOP_STATUS_PLAYLIST = 2,
  UNRECOGNIZED = -1,
}

export function loopStatusFromJSON(object: any): LoopStatus {
  switch (object) {
    case 0:
    case "LOOP_STATUS_NONE":
      return LoopStatus.LOOP_STATUS_NONE;
    case 1:
    case "LOOP_STATUS_TRACK":
      return LoopStatus.LOOP_STATUS_TRACK;
    case 2:
    case "LOOP_STATUS_PLAYLIST":
      return LoopStatus.LOOP_STATUS_PLAYLIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoopStatus.UNRECOGNIZED;
  }
}

export function loopStatusToJSON(object: LoopStatus): string {
  switch (object) {
    case LoopStatus.LOOP_STATUS_NONE:
      return "LOOP_STATUS_NONE";
    case LoopStatus.LOOP_STATUS_TRACK:
      return "LOOP_STATUS_TRACK";
    case LoopStatus.LOOP_STATUS_PLAYLIST:
      return "LOOP_STATUS_PLAYLIST";
    case LoopStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Property {
  PROPERTY_CAN_CONTROL = 0,
  PROPERTY_CAN_GO_NEXT = 1,
  PROPERTY_CAN_GO_PREVIOUS = 2,
  PROPERTY_CAN_PAUSE = 3,
  PROPERTY_CAN_PLAY = 4,
  PROPERTY_CAN_SEEK = 5,
  PROPERTY_LOOP_STATUS = 6,
  PROPERTY_MAXIMUM_RATE = 7,
  PROPERTY_METADATA = 8,
  PROPERTY_MINIMUM_RATE = 9,
  PROPERTY_PLAYBACK_STATUS = 10,
  PROPERTY_POSITION = 11,
  PROPERTY_RATE = 12,
  PROPERTY_SHUFFLE = 13,
  PROPERTY_VOLUME = 14,
  UNRECOGNIZED = -1,
}

export function propertyFromJSON(object: any): Property {
  switch (object) {
    case 0:
    case "PROPERTY_CAN_CONTROL":
      return Property.PROPERTY_CAN_CONTROL;
    case 1:
    case "PROPERTY_CAN_GO_NEXT":
      return Property.PROPERTY_CAN_GO_NEXT;
    case 2:
    case "PROPERTY_CAN_GO_PREVIOUS":
      return Property.PROPERTY_CAN_GO_PREVIOUS;
    case 3:
    case "PROPERTY_CAN_PAUSE":
      return Property.PROPERTY_CAN_PAUSE;
    case 4:
    case "PROPERTY_CAN_PLAY":
      return Property.PROPERTY_CAN_PLAY;
    case 5:
    case "PROPERTY_CAN_SEEK":
      return Property.PROPERTY_CAN_SEEK;
    case 6:
    case "PROPERTY_LOOP_STATUS":
      return Property.PROPERTY_LOOP_STATUS;
    case 7:
    case "PROPERTY_MAXIMUM_RATE":
      return Property.PROPERTY_MAXIMUM_RATE;
    case 8:
    case "PROPERTY_METADATA":
      return Property.PROPERTY_METADATA;
    case 9:
    case "PROPERTY_MINIMUM_RATE":
      return Property.PROPERTY_MINIMUM_RATE;
    case 10:
    case "PROPERTY_PLAYBACK_STATUS":
      return Property.PROPERTY_PLAYBACK_STATUS;
    case 11:
    case "PROPERTY_POSITION":
      return Property.PROPERTY_POSITION;
    case 12:
    case "PROPERTY_RATE":
      return Property.PROPERTY_RATE;
    case 13:
    case "PROPERTY_SHUFFLE":
      return Property.PROPERTY_SHUFFLE;
    case 14:
    case "PROPERTY_VOLUME":
      return Property.PROPERTY_VOLUME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Property.UNRECOGNIZED;
  }
}

export function propertyToJSON(object: Property): string {
  switch (object) {
    case Property.PROPERTY_CAN_CONTROL:
      return "PROPERTY_CAN_CONTROL";
    case Property.PROPERTY_CAN_GO_NEXT:
      return "PROPERTY_CAN_GO_NEXT";
    case Property.PROPERTY_CAN_GO_PREVIOUS:
      return "PROPERTY_CAN_GO_PREVIOUS";
    case Property.PROPERTY_CAN_PAUSE:
      return "PROPERTY_CAN_PAUSE";
    case Property.PROPERTY_CAN_PLAY:
      return "PROPERTY_CAN_PLAY";
    case Property.PROPERTY_CAN_SEEK:
      return "PROPERTY_CAN_SEEK";
    case Property.PROPERTY_LOOP_STATUS:
      return "PROPERTY_LOOP_STATUS";
    case Property.PROPERTY_MAXIMUM_RATE:
      return "PROPERTY_MAXIMUM_RATE";
    case Property.PROPERTY_METADATA:
      return "PROPERTY_METADATA";
    case Property.PROPERTY_MINIMUM_RATE:
      return "PROPERTY_MINIMUM_RATE";
    case Property.PROPERTY_PLAYBACK_STATUS:
      return "PROPERTY_PLAYBACK_STATUS";
    case Property.PROPERTY_POSITION:
      return "PROPERTY_POSITION";
    case Property.PROPERTY_RATE:
      return "PROPERTY_RATE";
    case Property.PROPERTY_SHUFFLE:
      return "PROPERTY_SHUFFLE";
    case Property.PROPERTY_VOLUME:
      return "PROPERTY_VOLUME";
    case Property.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Empty {
}

export interface LoopStatusOptional {
  none?: Empty | undefined;
  value?: LoopStatus | undefined;
}

export interface ShuffleOptional {
  none?: Empty | undefined;
  value?: boolean | undefined;
}

export interface PropertyUpdate {
  /** static */
  canControl?: boolean | undefined;
  canGoNext?: boolean | undefined;
  canGoPrevious?: boolean | undefined;
  canPause?: boolean | undefined;
  canPlay?: boolean | undefined;
  canSeek?:
    | boolean
    | undefined;
  /** can be written */
  loopStatus?: LoopStatusOptional | undefined;
  maximumRate?: number | undefined;
  metadata?: PropertyUpdate_Metadata | undefined;
  minimumRate?: number | undefined;
  playbackStatus?:
    | PropertyUpdate_PlaybackStatus
    | undefined;
  /** won't be announced */
  position?:
    | number
    | undefined;
  /** can be written */
  rate?:
    | number
    | undefined;
  /** can be written */
  shuffle?:
    | ShuffleOptional
    | undefined;
  /** can be written */
  volume?: number | undefined;
}

export enum PropertyUpdate_PlaybackStatus {
  PLAYBACK_STATUS_PLAYING = 0,
  PLAYBACK_STATUS_PAUSED = 1,
  PLAYBACK_STATUS_STOPPED = 2,
  UNRECOGNIZED = -1,
}

export function propertyUpdate_PlaybackStatusFromJSON(object: any): PropertyUpdate_PlaybackStatus {
  switch (object) {
    case 0:
    case "PLAYBACK_STATUS_PLAYING":
      return PropertyUpdate_PlaybackStatus.PLAYBACK_STATUS_PLAYING;
    case 1:
    case "PLAYBACK_STATUS_PAUSED":
      return PropertyUpdate_PlaybackStatus.PLAYBACK_STATUS_PAUSED;
    case 2:
    case "PLAYBACK_STATUS_STOPPED":
      return PropertyUpdate_PlaybackStatus.PLAYBACK_STATUS_STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PropertyUpdate_PlaybackStatus.UNRECOGNIZED;
  }
}

export function propertyUpdate_PlaybackStatusToJSON(object: PropertyUpdate_PlaybackStatus): string {
  switch (object) {
    case PropertyUpdate_PlaybackStatus.PLAYBACK_STATUS_PLAYING:
      return "PLAYBACK_STATUS_PLAYING";
    case PropertyUpdate_PlaybackStatus.PLAYBACK_STATUS_PAUSED:
      return "PLAYBACK_STATUS_PAUSED";
    case PropertyUpdate_PlaybackStatus.PLAYBACK_STATUS_STOPPED:
      return "PLAYBACK_STATUS_STOPPED";
    case PropertyUpdate_PlaybackStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PropertyUpdate_Metadata {
  /** https://www.freedesktop.org/wiki/Specifications/mpris-spec/metadata */
  oMprisTrackid: string;
  mprisLength?: number | undefined;
  mprisArtUrlBytes?: Uint8Array | undefined;
  xesamAlbum?: string | undefined;
  xesamAlbumArtist: string[];
  xesamArtist: string[];
  xesamAsText?: string | undefined;
  xesamAudioBpm?:
    | number
    | undefined;
  /** between 0 and 1 */
  xesamAutoRating?: number | undefined;
  xesamComment: string[];
  xesamComposer: string[];
  /** ISO 8601 extended format */
  dXesamContentCreated?: string | undefined;
  xesamDiscNumber?:
    | number
    | undefined;
  /** ISO 8601 extended format */
  dXesamFirstUsed?: string | undefined;
  xesamGenre: string[];
  /** ISO 8601 extended format */
  dXesamLastUsed?: string | undefined;
  xesamLyricist: string[];
  xesamTitle?: string | undefined;
  xesamTrackNumber?:
    | number
    | undefined;
  /** might as well include, maybe useful for some things. it's really a URI */
  xesamUrl?: string | undefined;
  xesamUseCount?:
    | number
    | undefined;
  /** between 0 and 1 */
  xesamUserRating?: number | undefined;
}

export interface SetLoopStatusRequest {
  loopStatus: LoopStatus;
}

export interface SetRateRequest {
  rate: number;
}

export interface SetShuffleRequest {
  shuffle: boolean;
}

export interface SetVolumeRequest {
  volume: number;
}

export interface SignalUpdate {
  seeked?: SignalUpdate_Seeked | undefined;
}

export interface SignalUpdate_Seeked {
  position: number;
}

export interface FetchPropertyRequest {
  property: Property;
}

export interface Update {
  property?: PropertyUpdate | undefined;
  signal?: SignalUpdate | undefined;
}

export interface OpenUriRequest {
  uri: string;
}

export interface SeekRequest {
  offset: number;
}

export interface SetPositionRequest {
  oTrackId: string;
  offset: number;
}

export interface RpcCall {
  callId: number;
  name: string;
  req: Uint8Array;
}

export interface RpcResponse {
  callId: number;
  res?: Uint8Array | undefined;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseLoopStatusOptional(): LoopStatusOptional {
  return { none: undefined, value: undefined };
}

export const LoopStatusOptional = {
  encode(message: LoopStatusOptional, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.none !== undefined) {
      Empty.encode(message.none, writer.uint32(10).fork()).ldelim();
    }
    if (message.value !== undefined) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoopStatusOptional {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoopStatusOptional();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.none = Empty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoopStatusOptional {
    return {
      none: isSet(object.none) ? Empty.fromJSON(object.none) : undefined,
      value: isSet(object.value) ? loopStatusFromJSON(object.value) : undefined,
    };
  },

  toJSON(message: LoopStatusOptional): unknown {
    const obj: any = {};
    if (message.none !== undefined) {
      obj.none = Empty.toJSON(message.none);
    }
    if (message.value !== undefined) {
      obj.value = loopStatusToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoopStatusOptional>, I>>(base?: I): LoopStatusOptional {
    return LoopStatusOptional.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoopStatusOptional>, I>>(object: I): LoopStatusOptional {
    const message = createBaseLoopStatusOptional();
    message.none = (object.none !== undefined && object.none !== null) ? Empty.fromPartial(object.none) : undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseShuffleOptional(): ShuffleOptional {
  return { none: undefined, value: undefined };
}

export const ShuffleOptional = {
  encode(message: ShuffleOptional, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.none !== undefined) {
      Empty.encode(message.none, writer.uint32(10).fork()).ldelim();
    }
    if (message.value !== undefined) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShuffleOptional {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShuffleOptional();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.none = Empty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShuffleOptional {
    return {
      none: isSet(object.none) ? Empty.fromJSON(object.none) : undefined,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : undefined,
    };
  },

  toJSON(message: ShuffleOptional): unknown {
    const obj: any = {};
    if (message.none !== undefined) {
      obj.none = Empty.toJSON(message.none);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShuffleOptional>, I>>(base?: I): ShuffleOptional {
    return ShuffleOptional.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShuffleOptional>, I>>(object: I): ShuffleOptional {
    const message = createBaseShuffleOptional();
    message.none = (object.none !== undefined && object.none !== null) ? Empty.fromPartial(object.none) : undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBasePropertyUpdate(): PropertyUpdate {
  return {
    canControl: undefined,
    canGoNext: undefined,
    canGoPrevious: undefined,
    canPause: undefined,
    canPlay: undefined,
    canSeek: undefined,
    loopStatus: undefined,
    maximumRate: undefined,
    metadata: undefined,
    minimumRate: undefined,
    playbackStatus: undefined,
    position: undefined,
    rate: undefined,
    shuffle: undefined,
    volume: undefined,
  };
}

export const PropertyUpdate = {
  encode(message: PropertyUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.canControl !== undefined) {
      writer.uint32(8).bool(message.canControl);
    }
    if (message.canGoNext !== undefined) {
      writer.uint32(16).bool(message.canGoNext);
    }
    if (message.canGoPrevious !== undefined) {
      writer.uint32(24).bool(message.canGoPrevious);
    }
    if (message.canPause !== undefined) {
      writer.uint32(32).bool(message.canPause);
    }
    if (message.canPlay !== undefined) {
      writer.uint32(40).bool(message.canPlay);
    }
    if (message.canSeek !== undefined) {
      writer.uint32(48).bool(message.canSeek);
    }
    if (message.loopStatus !== undefined) {
      LoopStatusOptional.encode(message.loopStatus, writer.uint32(58).fork()).ldelim();
    }
    if (message.maximumRate !== undefined) {
      writer.uint32(65).double(message.maximumRate);
    }
    if (message.metadata !== undefined) {
      PropertyUpdate_Metadata.encode(message.metadata, writer.uint32(74).fork()).ldelim();
    }
    if (message.minimumRate !== undefined) {
      writer.uint32(81).double(message.minimumRate);
    }
    if (message.playbackStatus !== undefined) {
      writer.uint32(88).int32(message.playbackStatus);
    }
    if (message.position !== undefined) {
      writer.uint32(96).int64(message.position);
    }
    if (message.rate !== undefined) {
      writer.uint32(105).double(message.rate);
    }
    if (message.shuffle !== undefined) {
      ShuffleOptional.encode(message.shuffle, writer.uint32(114).fork()).ldelim();
    }
    if (message.volume !== undefined) {
      writer.uint32(121).double(message.volume);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PropertyUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.canControl = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.canGoNext = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canGoPrevious = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canPause = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.canPlay = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.canSeek = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.loopStatus = LoopStatusOptional.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.maximumRate = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.metadata = PropertyUpdate_Metadata.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.minimumRate = reader.double();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.playbackStatus = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.position = longToNumber(reader.int64() as Long);
          continue;
        case 13:
          if (tag !== 105) {
            break;
          }

          message.rate = reader.double();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.shuffle = ShuffleOptional.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 121) {
            break;
          }

          message.volume = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyUpdate {
    return {
      canControl: isSet(object.canControl) ? globalThis.Boolean(object.canControl) : undefined,
      canGoNext: isSet(object.canGoNext) ? globalThis.Boolean(object.canGoNext) : undefined,
      canGoPrevious: isSet(object.canGoPrevious) ? globalThis.Boolean(object.canGoPrevious) : undefined,
      canPause: isSet(object.canPause) ? globalThis.Boolean(object.canPause) : undefined,
      canPlay: isSet(object.canPlay) ? globalThis.Boolean(object.canPlay) : undefined,
      canSeek: isSet(object.canSeek) ? globalThis.Boolean(object.canSeek) : undefined,
      loopStatus: isSet(object.loopStatus) ? LoopStatusOptional.fromJSON(object.loopStatus) : undefined,
      maximumRate: isSet(object.maximumRate) ? globalThis.Number(object.maximumRate) : undefined,
      metadata: isSet(object.metadata) ? PropertyUpdate_Metadata.fromJSON(object.metadata) : undefined,
      minimumRate: isSet(object.minimumRate) ? globalThis.Number(object.minimumRate) : undefined,
      playbackStatus: isSet(object.playbackStatus)
        ? propertyUpdate_PlaybackStatusFromJSON(object.playbackStatus)
        : undefined,
      position: isSet(object.position) ? globalThis.Number(object.position) : undefined,
      rate: isSet(object.rate) ? globalThis.Number(object.rate) : undefined,
      shuffle: isSet(object.shuffle) ? ShuffleOptional.fromJSON(object.shuffle) : undefined,
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : undefined,
    };
  },

  toJSON(message: PropertyUpdate): unknown {
    const obj: any = {};
    if (message.canControl !== undefined) {
      obj.canControl = message.canControl;
    }
    if (message.canGoNext !== undefined) {
      obj.canGoNext = message.canGoNext;
    }
    if (message.canGoPrevious !== undefined) {
      obj.canGoPrevious = message.canGoPrevious;
    }
    if (message.canPause !== undefined) {
      obj.canPause = message.canPause;
    }
    if (message.canPlay !== undefined) {
      obj.canPlay = message.canPlay;
    }
    if (message.canSeek !== undefined) {
      obj.canSeek = message.canSeek;
    }
    if (message.loopStatus !== undefined) {
      obj.loopStatus = LoopStatusOptional.toJSON(message.loopStatus);
    }
    if (message.maximumRate !== undefined) {
      obj.maximumRate = message.maximumRate;
    }
    if (message.metadata !== undefined) {
      obj.metadata = PropertyUpdate_Metadata.toJSON(message.metadata);
    }
    if (message.minimumRate !== undefined) {
      obj.minimumRate = message.minimumRate;
    }
    if (message.playbackStatus !== undefined) {
      obj.playbackStatus = propertyUpdate_PlaybackStatusToJSON(message.playbackStatus);
    }
    if (message.position !== undefined) {
      obj.position = Math.round(message.position);
    }
    if (message.rate !== undefined) {
      obj.rate = message.rate;
    }
    if (message.shuffle !== undefined) {
      obj.shuffle = ShuffleOptional.toJSON(message.shuffle);
    }
    if (message.volume !== undefined) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyUpdate>, I>>(base?: I): PropertyUpdate {
    return PropertyUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyUpdate>, I>>(object: I): PropertyUpdate {
    const message = createBasePropertyUpdate();
    message.canControl = object.canControl ?? undefined;
    message.canGoNext = object.canGoNext ?? undefined;
    message.canGoPrevious = object.canGoPrevious ?? undefined;
    message.canPause = object.canPause ?? undefined;
    message.canPlay = object.canPlay ?? undefined;
    message.canSeek = object.canSeek ?? undefined;
    message.loopStatus = (object.loopStatus !== undefined && object.loopStatus !== null)
      ? LoopStatusOptional.fromPartial(object.loopStatus)
      : undefined;
    message.maximumRate = object.maximumRate ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? PropertyUpdate_Metadata.fromPartial(object.metadata)
      : undefined;
    message.minimumRate = object.minimumRate ?? undefined;
    message.playbackStatus = object.playbackStatus ?? undefined;
    message.position = object.position ?? undefined;
    message.rate = object.rate ?? undefined;
    message.shuffle = (object.shuffle !== undefined && object.shuffle !== null)
      ? ShuffleOptional.fromPartial(object.shuffle)
      : undefined;
    message.volume = object.volume ?? undefined;
    return message;
  },
};

function createBasePropertyUpdate_Metadata(): PropertyUpdate_Metadata {
  return {
    oMprisTrackid: "",
    mprisLength: undefined,
    mprisArtUrlBytes: undefined,
    xesamAlbum: undefined,
    xesamAlbumArtist: [],
    xesamArtist: [],
    xesamAsText: undefined,
    xesamAudioBpm: undefined,
    xesamAutoRating: undefined,
    xesamComment: [],
    xesamComposer: [],
    dXesamContentCreated: undefined,
    xesamDiscNumber: undefined,
    dXesamFirstUsed: undefined,
    xesamGenre: [],
    dXesamLastUsed: undefined,
    xesamLyricist: [],
    xesamTitle: undefined,
    xesamTrackNumber: undefined,
    xesamUrl: undefined,
    xesamUseCount: undefined,
    xesamUserRating: undefined,
  };
}

export const PropertyUpdate_Metadata = {
  encode(message: PropertyUpdate_Metadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oMprisTrackid !== "") {
      writer.uint32(10).string(message.oMprisTrackid);
    }
    if (message.mprisLength !== undefined) {
      writer.uint32(16).int64(message.mprisLength);
    }
    if (message.mprisArtUrlBytes !== undefined) {
      writer.uint32(26).bytes(message.mprisArtUrlBytes);
    }
    if (message.xesamAlbum !== undefined) {
      writer.uint32(34).string(message.xesamAlbum);
    }
    for (const v of message.xesamAlbumArtist) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.xesamArtist) {
      writer.uint32(50).string(v!);
    }
    if (message.xesamAsText !== undefined) {
      writer.uint32(58).string(message.xesamAsText);
    }
    if (message.xesamAudioBpm !== undefined) {
      writer.uint32(64).uint32(message.xesamAudioBpm);
    }
    if (message.xesamAutoRating !== undefined) {
      writer.uint32(77).float(message.xesamAutoRating);
    }
    for (const v of message.xesamComment) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.xesamComposer) {
      writer.uint32(90).string(v!);
    }
    if (message.dXesamContentCreated !== undefined) {
      writer.uint32(98).string(message.dXesamContentCreated);
    }
    if (message.xesamDiscNumber !== undefined) {
      writer.uint32(104).int32(message.xesamDiscNumber);
    }
    if (message.dXesamFirstUsed !== undefined) {
      writer.uint32(114).string(message.dXesamFirstUsed);
    }
    for (const v of message.xesamGenre) {
      writer.uint32(122).string(v!);
    }
    if (message.dXesamLastUsed !== undefined) {
      writer.uint32(130).string(message.dXesamLastUsed);
    }
    for (const v of message.xesamLyricist) {
      writer.uint32(138).string(v!);
    }
    if (message.xesamTitle !== undefined) {
      writer.uint32(146).string(message.xesamTitle);
    }
    if (message.xesamTrackNumber !== undefined) {
      writer.uint32(152).int32(message.xesamTrackNumber);
    }
    if (message.xesamUrl !== undefined) {
      writer.uint32(162).string(message.xesamUrl);
    }
    if (message.xesamUseCount !== undefined) {
      writer.uint32(168).uint32(message.xesamUseCount);
    }
    if (message.xesamUserRating !== undefined) {
      writer.uint32(181).float(message.xesamUserRating);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PropertyUpdate_Metadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyUpdate_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oMprisTrackid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mprisLength = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mprisArtUrlBytes = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.xesamAlbum = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.xesamAlbumArtist.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.xesamArtist.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.xesamAsText = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.xesamAudioBpm = reader.uint32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.xesamAutoRating = reader.float();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.xesamComment.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.xesamComposer.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.dXesamContentCreated = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.xesamDiscNumber = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.dXesamFirstUsed = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.xesamGenre.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.dXesamLastUsed = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.xesamLyricist.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.xesamTitle = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.xesamTrackNumber = reader.int32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.xesamUrl = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.xesamUseCount = reader.uint32();
          continue;
        case 22:
          if (tag !== 181) {
            break;
          }

          message.xesamUserRating = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyUpdate_Metadata {
    return {
      oMprisTrackid: isSet(object.oMprisTrackid) ? globalThis.String(object.oMprisTrackid) : "",
      mprisLength: isSet(object.mprisLength) ? globalThis.Number(object.mprisLength) : undefined,
      mprisArtUrlBytes: isSet(object.mprisArtUrlBytes) ? bytesFromBase64(object.mprisArtUrlBytes) : undefined,
      xesamAlbum: isSet(object.xesamAlbum) ? globalThis.String(object.xesamAlbum) : undefined,
      xesamAlbumArtist: globalThis.Array.isArray(object?.xesamAlbumArtist)
        ? object.xesamAlbumArtist.map((e: any) => globalThis.String(e))
        : [],
      xesamArtist: globalThis.Array.isArray(object?.xesamArtist)
        ? object.xesamArtist.map((e: any) => globalThis.String(e))
        : [],
      xesamAsText: isSet(object.xesamAsText) ? globalThis.String(object.xesamAsText) : undefined,
      xesamAudioBpm: isSet(object.xesamAudioBpm) ? globalThis.Number(object.xesamAudioBpm) : undefined,
      xesamAutoRating: isSet(object.xesamAutoRating) ? globalThis.Number(object.xesamAutoRating) : undefined,
      xesamComment: globalThis.Array.isArray(object?.xesamComment)
        ? object.xesamComment.map((e: any) => globalThis.String(e))
        : [],
      xesamComposer: globalThis.Array.isArray(object?.xesamComposer)
        ? object.xesamComposer.map((e: any) => globalThis.String(e))
        : [],
      dXesamContentCreated: isSet(object.dXesamContentCreated)
        ? globalThis.String(object.dXesamContentCreated)
        : undefined,
      xesamDiscNumber: isSet(object.xesamDiscNumber) ? globalThis.Number(object.xesamDiscNumber) : undefined,
      dXesamFirstUsed: isSet(object.dXesamFirstUsed) ? globalThis.String(object.dXesamFirstUsed) : undefined,
      xesamGenre: globalThis.Array.isArray(object?.xesamGenre)
        ? object.xesamGenre.map((e: any) => globalThis.String(e))
        : [],
      dXesamLastUsed: isSet(object.dXesamLastUsed) ? globalThis.String(object.dXesamLastUsed) : undefined,
      xesamLyricist: globalThis.Array.isArray(object?.xesamLyricist)
        ? object.xesamLyricist.map((e: any) => globalThis.String(e))
        : [],
      xesamTitle: isSet(object.xesamTitle) ? globalThis.String(object.xesamTitle) : undefined,
      xesamTrackNumber: isSet(object.xesamTrackNumber) ? globalThis.Number(object.xesamTrackNumber) : undefined,
      xesamUrl: isSet(object.xesamUrl) ? globalThis.String(object.xesamUrl) : undefined,
      xesamUseCount: isSet(object.xesamUseCount) ? globalThis.Number(object.xesamUseCount) : undefined,
      xesamUserRating: isSet(object.xesamUserRating) ? globalThis.Number(object.xesamUserRating) : undefined,
    };
  },

  toJSON(message: PropertyUpdate_Metadata): unknown {
    const obj: any = {};
    if (message.oMprisTrackid !== "") {
      obj.oMprisTrackid = message.oMprisTrackid;
    }
    if (message.mprisLength !== undefined) {
      obj.mprisLength = Math.round(message.mprisLength);
    }
    if (message.mprisArtUrlBytes !== undefined) {
      obj.mprisArtUrlBytes = base64FromBytes(message.mprisArtUrlBytes);
    }
    if (message.xesamAlbum !== undefined) {
      obj.xesamAlbum = message.xesamAlbum;
    }
    if (message.xesamAlbumArtist?.length) {
      obj.xesamAlbumArtist = message.xesamAlbumArtist;
    }
    if (message.xesamArtist?.length) {
      obj.xesamArtist = message.xesamArtist;
    }
    if (message.xesamAsText !== undefined) {
      obj.xesamAsText = message.xesamAsText;
    }
    if (message.xesamAudioBpm !== undefined) {
      obj.xesamAudioBpm = Math.round(message.xesamAudioBpm);
    }
    if (message.xesamAutoRating !== undefined) {
      obj.xesamAutoRating = message.xesamAutoRating;
    }
    if (message.xesamComment?.length) {
      obj.xesamComment = message.xesamComment;
    }
    if (message.xesamComposer?.length) {
      obj.xesamComposer = message.xesamComposer;
    }
    if (message.dXesamContentCreated !== undefined) {
      obj.dXesamContentCreated = message.dXesamContentCreated;
    }
    if (message.xesamDiscNumber !== undefined) {
      obj.xesamDiscNumber = Math.round(message.xesamDiscNumber);
    }
    if (message.dXesamFirstUsed !== undefined) {
      obj.dXesamFirstUsed = message.dXesamFirstUsed;
    }
    if (message.xesamGenre?.length) {
      obj.xesamGenre = message.xesamGenre;
    }
    if (message.dXesamLastUsed !== undefined) {
      obj.dXesamLastUsed = message.dXesamLastUsed;
    }
    if (message.xesamLyricist?.length) {
      obj.xesamLyricist = message.xesamLyricist;
    }
    if (message.xesamTitle !== undefined) {
      obj.xesamTitle = message.xesamTitle;
    }
    if (message.xesamTrackNumber !== undefined) {
      obj.xesamTrackNumber = Math.round(message.xesamTrackNumber);
    }
    if (message.xesamUrl !== undefined) {
      obj.xesamUrl = message.xesamUrl;
    }
    if (message.xesamUseCount !== undefined) {
      obj.xesamUseCount = Math.round(message.xesamUseCount);
    }
    if (message.xesamUserRating !== undefined) {
      obj.xesamUserRating = message.xesamUserRating;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyUpdate_Metadata>, I>>(base?: I): PropertyUpdate_Metadata {
    return PropertyUpdate_Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyUpdate_Metadata>, I>>(object: I): PropertyUpdate_Metadata {
    const message = createBasePropertyUpdate_Metadata();
    message.oMprisTrackid = object.oMprisTrackid ?? "";
    message.mprisLength = object.mprisLength ?? undefined;
    message.mprisArtUrlBytes = object.mprisArtUrlBytes ?? undefined;
    message.xesamAlbum = object.xesamAlbum ?? undefined;
    message.xesamAlbumArtist = object.xesamAlbumArtist?.map((e) => e) || [];
    message.xesamArtist = object.xesamArtist?.map((e) => e) || [];
    message.xesamAsText = object.xesamAsText ?? undefined;
    message.xesamAudioBpm = object.xesamAudioBpm ?? undefined;
    message.xesamAutoRating = object.xesamAutoRating ?? undefined;
    message.xesamComment = object.xesamComment?.map((e) => e) || [];
    message.xesamComposer = object.xesamComposer?.map((e) => e) || [];
    message.dXesamContentCreated = object.dXesamContentCreated ?? undefined;
    message.xesamDiscNumber = object.xesamDiscNumber ?? undefined;
    message.dXesamFirstUsed = object.dXesamFirstUsed ?? undefined;
    message.xesamGenre = object.xesamGenre?.map((e) => e) || [];
    message.dXesamLastUsed = object.dXesamLastUsed ?? undefined;
    message.xesamLyricist = object.xesamLyricist?.map((e) => e) || [];
    message.xesamTitle = object.xesamTitle ?? undefined;
    message.xesamTrackNumber = object.xesamTrackNumber ?? undefined;
    message.xesamUrl = object.xesamUrl ?? undefined;
    message.xesamUseCount = object.xesamUseCount ?? undefined;
    message.xesamUserRating = object.xesamUserRating ?? undefined;
    return message;
  },
};

function createBaseSetLoopStatusRequest(): SetLoopStatusRequest {
  return { loopStatus: 0 };
}

export const SetLoopStatusRequest = {
  encode(message: SetLoopStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.loopStatus !== 0) {
      writer.uint32(8).int32(message.loopStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetLoopStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLoopStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.loopStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLoopStatusRequest {
    return { loopStatus: isSet(object.loopStatus) ? loopStatusFromJSON(object.loopStatus) : 0 };
  },

  toJSON(message: SetLoopStatusRequest): unknown {
    const obj: any = {};
    if (message.loopStatus !== 0) {
      obj.loopStatus = loopStatusToJSON(message.loopStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetLoopStatusRequest>, I>>(base?: I): SetLoopStatusRequest {
    return SetLoopStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetLoopStatusRequest>, I>>(object: I): SetLoopStatusRequest {
    const message = createBaseSetLoopStatusRequest();
    message.loopStatus = object.loopStatus ?? 0;
    return message;
  },
};

function createBaseSetRateRequest(): SetRateRequest {
  return { rate: 0 };
}

export const SetRateRequest = {
  encode(message: SetRateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rate !== 0) {
      writer.uint32(9).double(message.rate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetRateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.rate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetRateRequest {
    return { rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0 };
  },

  toJSON(message: SetRateRequest): unknown {
    const obj: any = {};
    if (message.rate !== 0) {
      obj.rate = message.rate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRateRequest>, I>>(base?: I): SetRateRequest {
    return SetRateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRateRequest>, I>>(object: I): SetRateRequest {
    const message = createBaseSetRateRequest();
    message.rate = object.rate ?? 0;
    return message;
  },
};

function createBaseSetShuffleRequest(): SetShuffleRequest {
  return { shuffle: false };
}

export const SetShuffleRequest = {
  encode(message: SetShuffleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shuffle !== false) {
      writer.uint32(8).bool(message.shuffle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetShuffleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetShuffleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shuffle = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetShuffleRequest {
    return { shuffle: isSet(object.shuffle) ? globalThis.Boolean(object.shuffle) : false };
  },

  toJSON(message: SetShuffleRequest): unknown {
    const obj: any = {};
    if (message.shuffle !== false) {
      obj.shuffle = message.shuffle;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetShuffleRequest>, I>>(base?: I): SetShuffleRequest {
    return SetShuffleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetShuffleRequest>, I>>(object: I): SetShuffleRequest {
    const message = createBaseSetShuffleRequest();
    message.shuffle = object.shuffle ?? false;
    return message;
  },
};

function createBaseSetVolumeRequest(): SetVolumeRequest {
  return { volume: 0 };
}

export const SetVolumeRequest = {
  encode(message: SetVolumeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.volume !== 0) {
      writer.uint32(9).double(message.volume);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetVolumeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.volume = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetVolumeRequest {
    return { volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0 };
  },

  toJSON(message: SetVolumeRequest): unknown {
    const obj: any = {};
    if (message.volume !== 0) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetVolumeRequest>, I>>(base?: I): SetVolumeRequest {
    return SetVolumeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetVolumeRequest>, I>>(object: I): SetVolumeRequest {
    const message = createBaseSetVolumeRequest();
    message.volume = object.volume ?? 0;
    return message;
  },
};

function createBaseSignalUpdate(): SignalUpdate {
  return { seeked: undefined };
}

export const SignalUpdate = {
  encode(message: SignalUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.seeked !== undefined) {
      SignalUpdate_Seeked.encode(message.seeked, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignalUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.seeked = SignalUpdate_Seeked.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalUpdate {
    return { seeked: isSet(object.seeked) ? SignalUpdate_Seeked.fromJSON(object.seeked) : undefined };
  },

  toJSON(message: SignalUpdate): unknown {
    const obj: any = {};
    if (message.seeked !== undefined) {
      obj.seeked = SignalUpdate_Seeked.toJSON(message.seeked);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalUpdate>, I>>(base?: I): SignalUpdate {
    return SignalUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalUpdate>, I>>(object: I): SignalUpdate {
    const message = createBaseSignalUpdate();
    message.seeked = (object.seeked !== undefined && object.seeked !== null)
      ? SignalUpdate_Seeked.fromPartial(object.seeked)
      : undefined;
    return message;
  },
};

function createBaseSignalUpdate_Seeked(): SignalUpdate_Seeked {
  return { position: 0 };
}

export const SignalUpdate_Seeked = {
  encode(message: SignalUpdate_Seeked, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== 0) {
      writer.uint32(8).int64(message.position);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignalUpdate_Seeked {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalUpdate_Seeked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.position = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalUpdate_Seeked {
    return { position: isSet(object.position) ? globalThis.Number(object.position) : 0 };
  },

  toJSON(message: SignalUpdate_Seeked): unknown {
    const obj: any = {};
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalUpdate_Seeked>, I>>(base?: I): SignalUpdate_Seeked {
    return SignalUpdate_Seeked.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalUpdate_Seeked>, I>>(object: I): SignalUpdate_Seeked {
    const message = createBaseSignalUpdate_Seeked();
    message.position = object.position ?? 0;
    return message;
  },
};

function createBaseFetchPropertyRequest(): FetchPropertyRequest {
  return { property: 0 };
}

export const FetchPropertyRequest = {
  encode(message: FetchPropertyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.property !== 0) {
      writer.uint32(8).int32(message.property);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FetchPropertyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchPropertyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.property = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchPropertyRequest {
    return { property: isSet(object.property) ? propertyFromJSON(object.property) : 0 };
  },

  toJSON(message: FetchPropertyRequest): unknown {
    const obj: any = {};
    if (message.property !== 0) {
      obj.property = propertyToJSON(message.property);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FetchPropertyRequest>, I>>(base?: I): FetchPropertyRequest {
    return FetchPropertyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FetchPropertyRequest>, I>>(object: I): FetchPropertyRequest {
    const message = createBaseFetchPropertyRequest();
    message.property = object.property ?? 0;
    return message;
  },
};

function createBaseUpdate(): Update {
  return { property: undefined, signal: undefined };
}

export const Update = {
  encode(message: Update, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.property !== undefined) {
      PropertyUpdate.encode(message.property, writer.uint32(10).fork()).ldelim();
    }
    if (message.signal !== undefined) {
      SignalUpdate.encode(message.signal, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Update {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = PropertyUpdate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signal = SignalUpdate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Update {
    return {
      property: isSet(object.property) ? PropertyUpdate.fromJSON(object.property) : undefined,
      signal: isSet(object.signal) ? SignalUpdate.fromJSON(object.signal) : undefined,
    };
  },

  toJSON(message: Update): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = PropertyUpdate.toJSON(message.property);
    }
    if (message.signal !== undefined) {
      obj.signal = SignalUpdate.toJSON(message.signal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Update>, I>>(base?: I): Update {
    return Update.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Update>, I>>(object: I): Update {
    const message = createBaseUpdate();
    message.property = (object.property !== undefined && object.property !== null)
      ? PropertyUpdate.fromPartial(object.property)
      : undefined;
    message.signal = (object.signal !== undefined && object.signal !== null)
      ? SignalUpdate.fromPartial(object.signal)
      : undefined;
    return message;
  },
};

function createBaseOpenUriRequest(): OpenUriRequest {
  return { uri: "" };
}

export const OpenUriRequest = {
  encode(message: OpenUriRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OpenUriRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenUriRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenUriRequest {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: OpenUriRequest): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenUriRequest>, I>>(base?: I): OpenUriRequest {
    return OpenUriRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenUriRequest>, I>>(object: I): OpenUriRequest {
    const message = createBaseOpenUriRequest();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseSeekRequest(): SeekRequest {
  return { offset: 0 };
}

export const SeekRequest = {
  encode(message: SeekRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offset !== 0) {
      writer.uint32(8).int64(message.offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SeekRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeekRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeekRequest {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: SeekRequest): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SeekRequest>, I>>(base?: I): SeekRequest {
    return SeekRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SeekRequest>, I>>(object: I): SeekRequest {
    const message = createBaseSeekRequest();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseSetPositionRequest(): SetPositionRequest {
  return { oTrackId: "", offset: 0 };
}

export const SetPositionRequest = {
  encode(message: SetPositionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oTrackId !== "") {
      writer.uint32(10).string(message.oTrackId);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetPositionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetPositionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oTrackId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetPositionRequest {
    return {
      oTrackId: isSet(object.oTrackId) ? globalThis.String(object.oTrackId) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: SetPositionRequest): unknown {
    const obj: any = {};
    if (message.oTrackId !== "") {
      obj.oTrackId = message.oTrackId;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetPositionRequest>, I>>(base?: I): SetPositionRequest {
    return SetPositionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetPositionRequest>, I>>(object: I): SetPositionRequest {
    const message = createBaseSetPositionRequest();
    message.oTrackId = object.oTrackId ?? "";
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseRpcCall(): RpcCall {
  return { callId: 0, name: "", req: new Uint8Array(0) };
}

export const RpcCall = {
  encode(message: RpcCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.callId !== 0) {
      writer.uint32(8).int64(message.callId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.req.length !== 0) {
      writer.uint32(26).bytes(message.req);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RpcCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.callId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.req = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcCall {
    return {
      callId: isSet(object.callId) ? globalThis.Number(object.callId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      req: isSet(object.req) ? bytesFromBase64(object.req) : new Uint8Array(0),
    };
  },

  toJSON(message: RpcCall): unknown {
    const obj: any = {};
    if (message.callId !== 0) {
      obj.callId = Math.round(message.callId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.req.length !== 0) {
      obj.req = base64FromBytes(message.req);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcCall>, I>>(base?: I): RpcCall {
    return RpcCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcCall>, I>>(object: I): RpcCall {
    const message = createBaseRpcCall();
    message.callId = object.callId ?? 0;
    message.name = object.name ?? "";
    message.req = object.req ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRpcResponse(): RpcResponse {
  return { callId: 0, res: undefined };
}

export const RpcResponse = {
  encode(message: RpcResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.callId !== 0) {
      writer.uint32(8).int64(message.callId);
    }
    if (message.res !== undefined) {
      writer.uint32(18).bytes(message.res);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RpcResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.callId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.res = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcResponse {
    return {
      callId: isSet(object.callId) ? globalThis.Number(object.callId) : 0,
      res: isSet(object.res) ? bytesFromBase64(object.res) : undefined,
    };
  },

  toJSON(message: RpcResponse): unknown {
    const obj: any = {};
    if (message.callId !== 0) {
      obj.callId = Math.round(message.callId);
    }
    if (message.res !== undefined) {
      obj.res = base64FromBytes(message.res);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcResponse>, I>>(base?: I): RpcResponse {
    return RpcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcResponse>, I>>(object: I): RpcResponse {
    const message = createBaseRpcResponse();
    message.callId = object.callId ?? 0;
    message.res = object.res ?? undefined;
    return message;
  },
};

export interface MPRIS {
  FetchProperty(request: FetchPropertyRequest): Promise<PropertyUpdate>;
  Subscribe(request: Empty): Observable<Update>;
  Next(request: Empty): Promise<Empty>;
  OpenUri(request: OpenUriRequest): Promise<Empty>;
  Pause(request: Empty): Promise<Empty>;
  Play(request: Empty): Promise<Empty>;
  PlayPause(request: Empty): Promise<Empty>;
  Previous(request: Empty): Promise<Empty>;
  Seek(request: SeekRequest): Promise<Empty>;
  SetPosition(request: SetPositionRequest): Promise<Empty>;
  Stop(request: Empty): Promise<Empty>;
  SetLoopStatus(request: SetLoopStatusRequest): Promise<Empty>;
  SetRate(request: SetRateRequest): Promise<Empty>;
  SetShuffle(request: SetShuffleRequest): Promise<Empty>;
  SetVolume(request: SetVolumeRequest): Promise<Empty>;
  Ping(request: Empty): Promise<Empty>;
}

export const MPRISServiceName = "MPRIS";
export class MPRISClientImpl implements MPRIS {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MPRISServiceName;
    this.rpc = rpc;
    this.FetchProperty = this.FetchProperty.bind(this);
    this.Subscribe = this.Subscribe.bind(this);
    this.Next = this.Next.bind(this);
    this.OpenUri = this.OpenUri.bind(this);
    this.Pause = this.Pause.bind(this);
    this.Play = this.Play.bind(this);
    this.PlayPause = this.PlayPause.bind(this);
    this.Previous = this.Previous.bind(this);
    this.Seek = this.Seek.bind(this);
    this.SetPosition = this.SetPosition.bind(this);
    this.Stop = this.Stop.bind(this);
    this.SetLoopStatus = this.SetLoopStatus.bind(this);
    this.SetRate = this.SetRate.bind(this);
    this.SetShuffle = this.SetShuffle.bind(this);
    this.SetVolume = this.SetVolume.bind(this);
    this.Ping = this.Ping.bind(this);
  }
  FetchProperty(request: FetchPropertyRequest): Promise<PropertyUpdate> {
    const data = FetchPropertyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FetchProperty", data);
    return promise.then((data) => PropertyUpdate.decode(_m0.Reader.create(data)));
  }

  Subscribe(request: Empty): Observable<Update> {
    const data = Empty.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Subscribe", data);
    return result.pipe(map((data) => Update.decode(_m0.Reader.create(data))));
  }

  Next(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Next", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  OpenUri(request: OpenUriRequest): Promise<Empty> {
    const data = OpenUriRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OpenUri", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  Pause(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Pause", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  Play(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Play", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  PlayPause(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlayPause", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  Previous(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Previous", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  Seek(request: SeekRequest): Promise<Empty> {
    const data = SeekRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Seek", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  SetPosition(request: SetPositionRequest): Promise<Empty> {
    const data = SetPositionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetPosition", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  Stop(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Stop", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  SetLoopStatus(request: SetLoopStatusRequest): Promise<Empty> {
    const data = SetLoopStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetLoopStatus", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  SetRate(request: SetRateRequest): Promise<Empty> {
    const data = SetRateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetRate", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  SetShuffle(request: SetShuffleRequest): Promise<Empty> {
    const data = SetShuffleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetShuffle", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  SetVolume(request: SetVolumeRequest): Promise<Empty> {
    const data = SetVolumeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetVolume", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  Ping(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Ping", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
